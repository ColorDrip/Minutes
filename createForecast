import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.seasonal import STL
from statsmodels.tsa.stattools import adfuller
from pmdarima import auto_arima
from sklearn.metrics import mean_absolute_error

# Step 1: Load and Prepare Data
data = pd.read_csv('your_file.csv')  # Replace with actual file path
data['date'] = pd.to_datetime(data['date'])
data.set_index('date', inplace=True)

# Ensure monthly frequency
data = data.asfreq('MS')  # Month Start; use 'M' for Month End
print(f"Data frequency detected: {data.index.freq}")

# Identify numeric columns
numerical_columns = data.select_dtypes(include=[np.number]).columns.tolist()
if not numerical_columns:
    raise ValueError("No numerical columns found in the CSV.")

# Step 2: Preprocess function
def preprocess_series(series):
    lower, upper = series.quantile([0.01, 0.99])
    series_cleaned = series.clip(lower=lower, upper=upper)
    series_smoothed = series_cleaned.ewm(span=3).mean().dropna()
    return series_smoothed

smoothed_data = pd.DataFrame(index=data.index)
for col in numerical_columns:
    smoothed_data[col] = preprocess_series(data[col])

# Step 3: STL Decomposition
for col in numerical_columns:
    try:
        stl = STL(smoothed_data[col], period=12)  # 12 for yearly seasonality in monthly data
        result = stl.fit()
        fig, axes = plt.subplots(4, 1, figsize=(10, 8))
        axes[0].plot(smoothed_data[col]); axes[0].set_title(f'Smoothed {col}')
        axes[1].plot(result.trend); axes[1].set_title('Trend')
        axes[2].plot(result.seasonal); axes[2].set_title('Seasonality')
        axes[3].plot(result.resid); axes[3].set_title('Residuals')
        plt.tight_layout()
        plt.show()
    except Exception as e:
        print(f"Decomposition failed for {col}: {e}")

# Step 4: Stationarity Check
def check_stationarity(series):
    result = adfuller(series.dropna())
    print(f'{series.name} - ADF Statistic: {result[0]}, p-value: {result[1]}')
    return result[1] < 0.05

stationary_data = pd.DataFrame(index=smoothed_data.index)
for col in numerical_columns:
    transformed = np.log(smoothed_data[col] + 1)
    if not check_stationarity(transformed):
        stationary_data[col] = transformed.diff().dropna()
    else:
        stationary_data[col] = transformed

# Step 5: Train/Test Split & Forecast (One Fit Per Column)
forecasts = {}
future_forecasts = {}
mses = {}
maes = {}
train_size = int(len(smoothed_data) * 0.7)

for col in numerical_columns:
    train = smoothed_data[col][:train_size]
    test = smoothed_data[col][train_size:]

    try:
        # Fit once
        model = auto_arima(train.asfreq('MS'), seasonal=True, m=12, suppress_warnings=True)
        model_fit = model.fit(train.asfreq('MS'))

        # Test forecast
        forecast_vals = model_fit.predict(n_periods=len(test))
        forecast = pd.Series(forecast_vals, index=test.index)
        forecasts[col] = forecast

        # Metrics
        mses[col] = ((forecast - test) ** 2).mean()
        maes[col] = mean_absolute_error(test, forecast)

        # Plot Train/Test Forecast
        plt.figure(figsize=(10, 5))
        plt.plot(train, label='Train')
        plt.plot(test, label='Test', color='orange')
        plt.plot(test.index, forecast, label='Forecast', color='green')
        plt.title(f'{col} - Train/Test Forecast')
        plt.legend()
        plt.show()

        print(f"{col} - MSE: {mses[col]:.2f}, MAE: {maes[col]:.2f}")

        # Future forecast
        future_dates = pd.date_range(start=smoothed_data.index[-1] + pd.offsets.MonthBegin(),
                                     periods=7, freq='MS')
        future_vals = model_fit.predict(n_periods=7)
        future_series = pd.Series(future_vals, index=future_dates)
        future_forecasts[col] = future_series

        # Plot future forecast
        plt.figure(figsize=(10, 5))
        plt.plot(smoothed_data[col], label='Smoothed Data')
        plt.plot(future_series.index, future_series, label='Future Forecast', color='red')
        plt.title(f'{col} - Future Forecast')
        plt.legend()
        plt.show()

    except Exception as e:
        print(f"ARIMA failed for {col}: {e}")

# Step 6: Save Future Forecasts
forecast_df = pd.DataFrame(future_forecasts)
forecast_df.to_csv('forecasted_values.csv')
print("Forecasted values saved to 'forecasted_values.csv'")