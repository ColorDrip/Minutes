import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error, mean_squared_error, r2_score
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from pmdarima import auto_arima
from prophet import Prophet
from sklearn.linear_model import LinearRegression
from pandas.tseries.offsets import MonthEnd
import warnings

# Suppress Prophet plotly warnings
warnings.filterwarnings("ignore", message=".*Plotly.*")

# ======= Load Data =======
df = pd.read_excel("your_file.xlsx")

# Parse DD-MM-YYYY format
df['Date'] = pd.to_datetime(df['Date'], dayfirst=True)

# Set Date index and resample monthly (mean aggregation)
df = df.set_index('Date').resample('M').mean()

# Drop completely empty columns
df = df.dropna(how='all', axis=1)

# ======= Metric Calculation Function =======
def calc_metrics(actual, predicted):
    mae = mean_absolute_error(actual, predicted)
    mape = mean_absolute_percentage_error(actual, predicted) * 100
    rmse = np.sqrt(mean_squared_error(actual, predicted))
    r2 = r2_score(actual, predicted)
    accuracy = 100 - mape  # Approx accuracy
    return {'MAE': mae, 'MAPE': mape, 'RMSE': rmse, 'R2': r2, 'Accuracy%': accuracy}

# ======= Storage =======
all_results = []
future_forecasts = []

# Forecast horizon
future_months = 6

# ======= Iterate Columns =======
for column in df.columns:
    series = df[column].dropna()

    # Skip if insufficient data
    if series.empty or len(series) < 2:
        print(f"Skipping {column} â€“ not enough data")
        continue

    dates = series.index
    y = series.values

    print(f"\n--- Forecasting {column} ---")

    # ========= 1. ETS (Holt-Winters) =========
    try:
        ets_model = ExponentialSmoothing(series, trend='add', seasonal=None).fit()
        ets_pred = ets_model.fittedvalues
        ets_metrics = calc_metrics(series, ets_pred)

        # Future forecast
        ets_future = ets_model.forecast(future_months)
    except:
        ets_pred = np.nan
        ets_metrics = {'MAE': np.nan, 'MAPE': np.nan, 'RMSE': np.nan, 'R2': np.nan, 'Accuracy%': np.nan}
        ets_future = pd.Series([np.nan]*future_months)

    # ========= 2. ARIMA =========
    try:
        arima_model = auto_arima(series, seasonal=False, stepwise=True, suppress_warnings=True)
        arima_pred = arima_model.predict_in_sample()
        arima_metrics = calc_metrics(series, arima_pred)

        # Future forecast
        future_index = pd.date_range(dates[-1] + MonthEnd(1), periods=future_months, freq='M')
        arima_future = pd.Series(arima_model.predict(n_periods=future_months), index=future_index)
    except:
        arima_pred = np.nan
        arima_metrics = {'MAE': np.nan, 'MAPE': np.nan, 'RMSE': np.nan, 'R2': np.nan, 'Accuracy%': np.nan}
        arima_future = pd.Series([np.nan]*future_months)

    # ========= 3. Prophet =========
    try:
        prophet_df = series.reset_index()
        prophet_df.columns = ['ds', 'y']
        prophet_model = Prophet(daily_seasonality=False, yearly_seasonality=True)
        prophet_model.fit(prophet_df)

        # In-sample predictions
        forecast = prophet_model.predict(prophet_df)
        prophet_pred = forecast['yhat'].values
        prophet_metrics = calc_metrics(series, prophet_pred)

        # Future forecast
        future_dates = pd.date_range(dates[-1] + MonthEnd(1), periods=future_months, freq='M')
        future_df = pd.DataFrame({'ds': future_dates})
        prophet_future = prophet_model.predict(future_df)['yhat'].values
    except:
        prophet_pred = np.nan
        prophet_metrics = {'MAE': np.nan, 'MAPE': np.nan, 'RMSE': np.nan, 'R2': np.nan, 'Accuracy%': np.nan}
        prophet_future = [np.nan]*future_months

    # ========= 4. Linear Regression =========
    try:
        X = np.arange(len(series)).reshape(-1, 1)  # Time index
        lr_model = LinearRegression().fit(X, y)
        lr_pred = lr_model.predict(X)
        lr_metrics = calc_metrics(series, lr_pred)

        # Future forecast
        X_future = np.arange(len(series), len(series)+future_months).reshape(-1, 1)
        lr_future = lr_model.predict(X_future)
    except:
        lr_pred = np.nan
        lr_metrics = {'MAE': np.nan, 'MAPE': np.nan, 'RMSE': np.nan, 'R2': np.nan, 'Accuracy%': np.nan}
        lr_future = [np.nan]*future_months

    # ======= Collect Metrics =======
    models = ['ETS', 'ARIMA', 'Prophet', 'Linear Regression']
    preds = [ets_pred, arima_pred, prophet_pred, lr_pred]
    metrics_list = [ets_metrics, arima_metrics, prophet_metrics, lr_metrics]
    futures_list = [ets_future, arima_future, prophet_future, lr_future]

    for model_name, metrics in zip(models, metrics_list):
        all_results.append({
            'Column': column,
            'Model': model_name,
            **metrics
        })

    # ======= Future Forecast DataFrame =======
    future_df = pd.DataFrame({
        'Date': pd.date_range(dates[-1] + MonthEnd(1), periods=future_months, freq='M'),
        'ETS': futures_list[0].values if hasattr(futures_list[0], 'values') else futures_list[0],
        'ARIMA': futures_list[1].values if hasattr(futures_list[1], 'values') else futures_list[1],
        'Prophet': futures_list[2] if isinstance(futures_list[2], (list, np.ndarray)) else futures_list[2],
        'Linear Regression': futures_list[3] if isinstance(futures_list[3], (list, np.ndarray)) else futures_list[3]
    })
    future_df['Column'] = column
    future_forecasts.append(future_df)

    # ======= Plot Actual vs Predictions =======
    plt.figure(figsize=(10,5))
    plt.plot(dates, series, label='Actual', color='black', linewidth=2)
    for model_name, pred in zip(models, preds):
        if isinstance(pred, np.ndarray) or isinstance(pred, pd.Series):
            plt.plot(dates, pred, label=model_name)
    plt.title(f"{column} - Actual vs Predictions (Historical)")
    plt.legend()
    plt.grid(True)
    plt.show()

# ======= Save to Excel =======
metrics_df = pd.DataFrame(all_results)
future_df_final = pd.concat(future_forecasts)

with pd.ExcelWriter("forecast_results.xlsx") as writer:
    metrics_df.to_excel(writer, sheet_name='Model Metrics', index=False)
    future_df_final.to_excel(writer, sheet_name='Future Forecasts', index=False)

print("Results saved to forecast_results.xlsx")