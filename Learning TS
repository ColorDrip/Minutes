Step-by-Step with Synthetic Data

1. Generate Synthetic Data

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Create date range (5 years of monthly data)
dates = pd.date_range(start='2018-01-01', periods=60, freq='M')

# Generate components
np.random.seed(42)
trend = np.linspace(10, 50, 60)                  # Linear upward trend
seasonality = 10 * np.sin(2 * np.pi * dates.month / 12)  # Yearly seasonality
cycle = 5 * np.sin(2 * np.pi * dates.month / 36)         # Longer cycle
noise = np.random.normal(0, 2, 60)                       # Random noise

# Combine components
values = trend + seasonality + cycle + noise

# Create dataframe
data = pd.DataFrame({'Date': dates, 'Value': values})
data.set_index('Date', inplace=True)

# Plot synthetic data
plt.figure(figsize=(12,5))
sns.lineplot(x=data.index, y=data['Value'])
plt.title("Synthetic Time Series (Trend + Seasonality + Cycle + Noise)")
plt.show()


---

2. Decompose to See Components

from statsmodels.tsa.seasonal import seasonal_decompose

# Decompose (period=12 for monthly data)
decomposition = seasonal_decompose(data['Value'], model='additive', period=12)
decomposition.plot()
plt.show()

Observation: This separates trend, seasonal pattern, and residual noise.


---

3. Handle Noise (Smoothing)

# Smooth using rolling average (3 months window)
data['Smoothed'] = data['Value'].rolling(window=3).mean()

plt.figure(figsize=(12,5))
plt.plot(data.index, data['Value'], label='Original', alpha=0.5)
plt.plot(data.index, data['Smoothed'], label='Smoothed', color='red')
plt.title("Noise Reduction with Rolling Mean")
plt.legend()
plt.show()


---

4. Check Stationarity (ADF Test)

Stationary means no trend/seasonality â€” required for ARIMA.

from statsmodels.tsa.stattools import adfuller

def adf_test(series):
    result = adfuller(series.dropna())
    print("ADF Statistic:", result[0])
    print("p-value:", result[1])
    if result[1] <= 0.05:
        print("Data is Stationary")
    else:
        print("Data is NOT Stationary")

adf_test(data['Value'])


---

5. Remove Trend/Seasonality (Differencing)

If non-stationary, apply differencing.

# First difference
data['Diff1'] = data['Value'].diff()

adf_test(data['Diff1'])

# Seasonal differencing (12 months)
data['Diff12'] = data['Value'].diff(12)

adf_test(data['Diff12'])


---

6. Train-Test Split

# 80-20 split
train_size = int(len(data) * 0.8)
train, test = data['Value'][:train_size], data['Value'][train_size:]


---

7. Fit ARIMA Model

from statsmodels.tsa.arima.model import ARIMA

# Fit ARIMA(p,d,q) model (start with basic params)
model = ARIMA(train, order=(2,1,2))
model_fit = model.fit()

# Forecast
forecast = model_fit.forecast(steps=len(test))


---

8. Plot Forecast vs Actual

plt.figure(figsize=(12,5))
plt.plot(train, label='Train')
plt.plot(test, label='Test')
plt.plot(test.index, forecast, label='Forecast', color='red')
plt.title("Forecast vs Actual")
plt.legend()
plt.show()


---

9. Accuracy Metrics

from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np

mae = mean_absolute_error(test, forecast)
rmse = np.sqrt(mean_squared_error(test, forecast))

print("MAE:", round(mae, 2))
print("RMSE:", round(rmse, 2))

