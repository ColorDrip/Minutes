import pandas as pd
import matplotlib.pyplot as plt

# Load data
file_path = "your_file.csv"   # replace with your file
date_col = "Date"             # replace with your date column
value_col = "Cost"            # replace with your value column

data = pd.read_csv(file_path)

# Convert Date column to datetime
data[date_col] = pd.to_datetime(data[date_col], dayfirst=True)

# Set Date as index
data.set_index(date_col, inplace=True)

# Ensure monthly frequency
data = data.asfreq('M')

# Reindex to fill missing months (full range)
full_index = pd.date_range(start=data.index.min(), end=data.index.max(), freq='M')
data = data.reindex(full_index)

# Fill missing values (forward fill then backward fill)
data[value_col] = data[value_col].ffill().bfill()

plt.figure(figsize=(12, 6))
plt.plot(data[value_col], label='Monthly Cost')
plt.title("Monthly Cost Over Time")
plt.xlabel("Date")
plt.ylabel("Cost")
plt.legend()
plt.show()


from statsmodels.tsa.seasonal import seasonal_decompose

decomposition = seasonal_decompose(data[value_col], model='additive', period=12)
decomposition.plot()
plt.show()



from statsmodels.tsa.stattools import adfuller

def adf_test(series):
    result = adfuller(series.dropna())
    print("ADF Statistic:", result[0])
    print("p-value:", result[1])
    if result[1] <= 0.05:
        print("Data is Stationary")
    else:
        print("Data is NOT Stationary")

adf_test(data[value_col])


train_size = int(len(data) * 0.8)
train = data[value_col][:train_size]
test = data[value_col][train_size:]



import numpy as np
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Simple Average
simple_avg_forecast = pd.Series(train.mean(), index=test.index)

# Running Average (last 3 months)
window = 3
rolling_avg_forecast = pd.Series(train.rolling(window).mean().iloc[-1], index=test.index)

# Evaluate
def evaluate(actual, predicted, name):
    mae = mean_absolute_error(actual, predicted)
    rmse = np.sqrt(mean_squared_error(actual, predicted))
    print(f"{name} -> MAE: {mae:.2f}, RMSE: {rmse:.2f}")

evaluate(test, simple_avg_forecast, "Simple Average")
evaluate(test, rolling_avg_forecast, "Running Average")


from pmdarima import auto_arima

# Fit Auto ARIMA
arima_model = auto_arima(train, seasonal=True, m=12, trace=False, suppress_warnings=True)
print("Best ARIMA Model:", arima_model.order, arima_model.seasonal_order)

# Forecast
arima_forecast = pd.Series(arima_model.predict(n_periods=len(test)), index=test.index)

# Evaluate
evaluate(test, arima_forecast, "ARIMA")


future_forecast = arima_model.predict(n_periods=60)
future_dates = pd.date_range(start=data.index[-1] + pd.offsets.MonthBegin(1), periods=60, freq='M')
future_series = pd.Series(future_forecast, index=future_dates)

# Plot historical + forecast
plt.figure(figsize=(14, 6))
plt.plot(data[value_col], label='Historical Data')
plt.plot(future_series, label='5-Year Forecast', color='red')
plt.title("Forecast for Next 5 Years")
plt.legend()
plt.show()