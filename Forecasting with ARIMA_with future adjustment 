import pandas as pd
import numpy as np
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error, mean_squared_error, r2_score
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from pmdarima import auto_arima
from prophet import Prophet
from sklearn.linear_model import LinearRegression
import warnings

warnings.filterwarnings("ignore", message=".*Plotly.*")
warnings.filterwarnings("ignore", category=FutureWarning)

# =======================================
# 1. Configurations
# =======================================
file_path = "your_file.xlsx"    # Input file path
future_months = 60              # Forecast horizon (5 years)

# =======================================
# 2. Helper Functions
# =======================================

def calc_metrics(actual, predicted):
    """Calculate error metrics for evaluation"""
    mae = mean_absolute_error(actual, predicted)
    mape = mean_absolute_percentage_error(actual, predicted) * 100
    rmse = np.sqrt(mean_squared_error(actual, predicted))
    r2 = r2_score(actual, predicted)
    accuracy = 100 - mape
    return {'MAE': mae, 'MAPE': mape, 'RMSE': rmse, 'R2': r2, 'Accuracy%': accuracy}

def fit_predict_model(model_func, train_series, pred_index):
    """
    Helper to fit model on train_series and forecast on pred_index
    Returns historical fitted values and forecast
    """
    try:
        fitted, forecast = model_func(train_series, pred_index)
    except:
        fitted = pd.Series([np.nan]*len(train_series), index=train_series.index)
        forecast = pd.Series([np.nan]*len(pred_index), index=pred_index)
    return fitted, forecast

# =======================================
# 3. Load & Preprocess Data
# =======================================

df = pd.read_excel(file_path)
df['Date'] = pd.to_datetime(df['Date'], dayfirst=True)
df = df.set_index('Date').resample('M').mean()
df = df.asfreq('M')
df = df.dropna(how='all', axis=1)

# =======================================
# 4. Storage
# =======================================
metrics_results = []
historical_predictions = []
future_forecasts = []

# =======================================
# 5. Model Functions
# =======================================

def ets_model(series, future_index):
    model = ExponentialSmoothing(series, trend='add', seasonal='add', seasonal_periods=12).fit()
    fitted = model.fittedvalues
    forecast = pd.Series(model.forecast(len(future_index)), index=future_index)
    return fitted, forecast

def arima_model(series, future_index):
    model = auto_arima(series, seasonal=False, stepwise=True, suppress_warnings=True)
    fitted = pd.Series(model.predict_in_sample(), index=series.index)
    forecast = pd.Series(model.predict(n_periods=len(future_index)), index=future_index)
    return fitted, forecast

def sarima_model(series, future_index):
    model = auto_arima(series, seasonal=True, m=12, stepwise=True, suppress_warnings=True)
    fitted = pd.Series(model.predict_in_sample(), index=series.index)
    forecast = pd.Series(model.predict(n_periods=len(future_index)), index=future_index)
    return fitted, forecast

def prophet_model(series, future_index):
    df_prophet = series.reset_index()
    df_prophet.columns = ['ds', 'y']
    model = Prophet(daily_seasonality=False, yearly_seasonality=True)
    model.fit(df_prophet)
    fitted = pd.Series(model.predict(df_prophet)['yhat'].values, index=series.index)
    future_df = pd.DataFrame({'ds': future_index})
    forecast = pd.Series(model.predict(future_df)['yhat'].values, index=future_index)
    return fitted, forecast

def lr_model(series, future_index):
    X = np.arange(len(series)).reshape(-1, 1)
    lr = LinearRegression().fit(X, series.values)
    fitted = pd.Series(lr.predict(X), index=series.index)
    X_future = np.arange(len(series), len(series)+len(future_index)).reshape(-1, 1)
    forecast = pd.Series(lr.predict(X_future), index=future_index)
    return fitted, forecast

# =======================================
# 6. Process Each Column
# =======================================
for column in df.columns:
    series = df[column]

    # Historical data (till today)
    today = pd.Timestamp.today().to_period('M').to_timestamp()
    historical = series.loc[series.index <= today].dropna()

    # Manual future data (actual values in future months)
    manual_future = series.loc[series.index > today].dropna()

    if historical.empty and manual_future.empty:
        print(f"Skipping {column} â€“ not enough data")
        continue

    # --- Step 1: Predict gap months (between historical and manual future) ---
    if not manual_future.empty:
        last_hist = historical.index[-1] if not historical.empty else None
        first_manual = manual_future.index[0]

        # Gap period
        if last_hist and first_manual > last_hist + pd.offsets.MonthEnd(1):
            gap_index = pd.date_range(last_hist + pd.DateOffset(months=1),
                                      first_manual - pd.DateOffset(months=1),
                                      freq='M')
        else:
            gap_index = []

        # Forecast gap using historical model
        combined_for_gap = historical.copy()
        _, gap_forecast = fit_predict_model(ets_model, combined_for_gap, gap_index)

        # Combine historical + gap forecast + manual future
        combined_series = pd.concat([historical, gap_forecast, manual_future]).sort_index()
    else:
        # No manual future, use historical as is
        combined_series = historical.copy()

    # Forecast horizon beyond last manual value (or historical if no manual)
    last_known_date = combined_series.index[-1]
    future_index = pd.date_range(last_known_date + pd.DateOffset(months=1),
                                 periods=future_months,
                                 freq='M')

    print(f"\n--- Processing {column} ---")

    # ---------------------------
    # Baseline: Simple Average
    # ---------------------------
    simple_avg_pred = pd.Series(historical.mean(), index=historical.index)
    simple_avg_future = pd.Series(combined_series.mean(), index=future_index)
    simple_avg_metrics = calc_metrics(historical, simple_avg_pred)

    # ---------------------------
    # Baseline: Running Average
    # ---------------------------
    run_avg_pred = historical.expanding().mean()
    run_avg_future = pd.Series(run_avg_pred.iloc[-1], index=future_index)
    run_avg_metrics = calc_metrics(historical, run_avg_pred)

    # ---------------------------
    # ETS
    # ---------------------------
    ets_hist, ets_future = fit_predict_model(ets_model, combined_series, future_index)
    ets_metrics = calc_metrics(historical, ets_hist.loc[historical.index])

    # ---------------------------
    # ARIMA
    # ---------------------------
    arima_hist, arima_future = fit_predict_model(arima_model, combined_series, future_index)
    arima_metrics = calc_metrics(historical, arima_hist.loc[historical.index])

    # ---------------------------
    # SARIMA
    # ---------------------------
    sarima_hist, sarima_future = fit_predict_model(sarima_model, combined_series, future_index)
    sarima_metrics = calc_metrics(historical, sarima_hist.loc[historical.index])

    # ---------------------------
    # Prophet
    # ---------------------------
    prophet_hist, prophet_future = fit_predict_model(prophet_model, combined_series, future_index)
    prophet_metrics = calc_metrics(historical, prophet_hist.loc[historical.index])

    # ---------------------------
    # Linear Regression
    # ---------------------------
    lr_hist, lr_future = fit_predict_model(lr_model, combined_series, future_index)
    lr_metrics = calc_metrics(historical, lr_hist.loc[historical.index])

    # ============================
    # Save Metrics
    # ============================
    models = ['Simple Average', 'Running Average', 'ETS', 'ARIMA', 'SARIMA', 'Prophet', 'Linear Regression']
    metrics_list = [simple_avg_metrics, run_avg_metrics, ets_metrics, arima_metrics,
                    sarima_metrics, prophet_metrics, lr_metrics]

    for model_name, metrics in zip(models, metrics_list):
        metrics_results.append({
            'Column': column,
            'Model': model_name,
            **metrics
        })

    # ============================
    # Save Historical Predictions
    # ============================
    hist_df = pd.DataFrame({
        'Date': historical.index,
        'Actual': historical.values,
        'Simple Average': simple_avg_pred.values,
        'Running Average': run_avg_pred.values,
        'ETS': ets_hist.loc[historical.index].values,
        'ARIMA': arima_hist.loc[historical.index].values,
        'SARIMA': sarima_hist.loc[historical.index].values,
        'Prophet': prophet_hist.loc[historical.index].values,
        'Linear Regression': lr_hist.loc[historical.index].values,
        'Column': column
    })
    historical_predictions.append(hist_df)

    # ============================
    # Save Future Forecasts
    # ============================
    future_df = pd.DataFrame({
        'Date': future_index,
        'Simple Average': simple_avg_future.values,
        'Running Average': run_avg_future.values,
        'ETS': ets_future.values,
        'ARIMA': arima_future.values,
        'SARIMA': sarima_future.values,
        'Prophet': prophet_future.values,
        'Linear Regression': lr_future.values,
        'Column': column
    })
    future_forecasts.append(future_df)

# =======================================
# 7. Combine Outputs for Qlik Sense
# =======================================
metrics_df = pd.DataFrame(metrics_results)
metrics_df['Type'] = 'Metric'

hist_df_final = pd.concat(historical_predictions)
hist_melt = hist_df_final.melt(id_vars=['Date', 'Actual', 'Column'],
                               var_name='Model',
                               value_name='Predicted')
hist_melt = hist_melt[hist_melt['Model'] != 'Actual']
hist_melt['Type'] = 'Historical'

future_df_final = pd.concat(future_forecasts)
future_melt = future_df_final.melt(id_vars=['Date', 'Column'],
                                   var_name='Model',
                                   value_name='Predicted')
future_melt['Type'] = 'Forecast'
future_melt['Actual'] = np.nan

combined_df = pd.concat([metrics_df, hist_melt, future_melt], ignore_index=True)

# Save single CSV for Qlik Sense
combined_df.to_csv("forecast_all_in_one.csv", index=False)

print("Unified forecast data saved to forecast_all_in_one.csv for Qlik Sense")